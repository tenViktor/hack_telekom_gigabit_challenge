from typing import Dict, Any, List
import json
import tempfile
import os
from datetime import datetime
import asyncio
from pathlib import Path


class SQLInjectionHandler:
    def __init__(self):
        # Ensure sqlmap is installed in the Docker container
        self.sqlmap_path = "/usr/local/bin/sqlmap"  # Will need to add to Dockerfile
        self.output_dir = "/data/sqlmap_results"
        Path(self.output_dir).mkdir(parents=True, exist_ok=True)

    async def test_vulnerability(self, target: Dict[str, Any]):
        # Create temporary file for sqlmap JSON output
        with tempfile.NamedTemporaryFile(suffix=".json", delete=False) as tf:
            output_file = tf.name

        try:
            # Prepare sqlmap command
            cmd = [
                self.sqlmap_path,
                "-u",
                target["url"],
                "--batch",  # Non-interactive mode
                "--random-agent",
                "--level",
                "1",
                "--risk",
                "1",
                "--threads",
                "1",
                "--output-dir",
                self.output_dir,
                "--json-output",
                output_file,
            ]

            # Add POST data if available
            if target.get("parameters"):
                cmd.extend(["--data", json.dumps(target["parameters"])])

            # Run sqlmap asynchronously
            process = await asyncio.create_subprocess_exec(
                *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await process.communicate()

            # Read results
            try:
                with open(output_file, "r") as f:
                    sqlmap_results = json.load(f)
            except (json.JSONDecodeError, FileNotFoundError):
                sqlmap_results = {}

            return self._process_results(
                sqlmap_results, stdout.decode(), stderr.decode()
            )

        finally:
            # Cleanup
            if os.path.exists(output_file):
                os.unlink(output_file)

    def _process_results(self, sqlmap_results: Dict, stdout: str, stderr: str) -> Dict:
        """Process and analyze sqlmap scan results"""
        return {
            "timestamp": datetime.now().isoformat(),
            "vulnerability_found": self._check_vulnerability_found(
                sqlmap_results, stdout
            ),
            "details": {
                "injectable_parameters": self._extract_injectable_parameters(
                    sqlmap_results
                ),
                "database_type": sqlmap_results.get("dbms", "unknown"),
                "payload_examples": self._extract_payloads(sqlmap_results),
                "risk_level": self._determine_risk_level(sqlmap_results),
            },
            "evidence": {
                "stdout": stdout[:1000],  # First 1000 chars
                "stderr": stderr[:1000],
                "raw_results": sqlmap_results,
            },
            "recommendations": self._generate_recommendations(sqlmap_results),
        }

    def _check_vulnerability_found(self, results: Dict, stdout: str) -> bool:
        """Check if any SQL injection vulnerability was found"""
        # Check results data
        if results.get("data", {}).get("vulnerable", False):
            return True

        # Check stdout for common indicators
        indicators = [
            "is vulnerable",
            "injection point",
            "parameter '",
            "the back-end DBMS is",
        ]
        return any(indicator in stdout.lower() for indicator in indicators)

    def _extract_injectable_parameters(self, results: Dict) -> List[str]:
        """Extract names of injectable parameters"""
        injectable = []

        # Check data section for vulnerable parameters
        data = results.get("data", {})
        if isinstance(data, dict):
            for param, details in data.items():
                if isinstance(details, dict) and details.get("vulnerable"):
                    injectable.append(param)

        return injectable

    def _extract_payloads(self, results: Dict) -> List[str]:
        """Extract successful payload examples"""
        payloads = []

        # Look for successful payloads in results
        data = results.get("data", {})
        if isinstance(data, dict):
            for param_data in data.values():
                if isinstance(param_data, dict):
                    if "payload" in param_data:
                        payloads.append(param_data["payload"])

        return payloads[:3]  # Return only first 3 examples

    def _determine_risk_level(self, results: Dict) -> str:
        """Determine the risk level based on findings"""
        if not results:
            return "unknown"

        # Check if any critical operations were possible
        data = results.get("data", {})
        if any(op in str(data).lower() for op in ["write", "admin", "file", "shell"]):
            return "high"
        elif self._check_vulnerability_found(results, ""):
            return "medium"
        return "low"

    def _generate_recommendations(self, results: Dict) -> List[str]:
        """Generate security recommendations based on findings"""
        recommendations = [
            "Implement prepared statements or stored procedures",
            "Use an ORM framework with proper escaping",
            "Implement input validation for all user inputs",
        ]

        # Add specific recommendations based on findings
        if "mysql" in str(results).lower():
            recommendations.append(
                "Use MySQL's mysql_real_escape_string() or equivalent"
            )
        if "postgres" in str(results).lower():
            recommendations.append(
                "Use PostgreSQL's parameterized queries with $1, $2 syntax"
            )
        if "windows" in str(results).lower():
            recommendations.append(
                "Ensure SQL Server is configured to use Windows Authentication"
            )

        return recommendations
